package com.gpgamelab.justpatience.viewmodel

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.google.gson.Gson
import com.gpgamelab.justpatience.data.SettingsManager
import com.gpgamelab.justpatience.data.TokenManager
import com.gpgamelab.justpatience.model.Card
import com.gpgamelab.justpatience.model.CardStack
import com.gpgamelab.justpatience.model.Game
import com.gpgamelab.justpatience.model.StackType
import com.gpgamelab.justpatience.presenter.GamePresenter
import com.gpgamelab.justpatience.repository.GameRepository
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

/**
 * ViewModel for the main game screen (HomeActivity).
 * It bridges the UI with the GamePresenter logic and the GameRepository persistence layer.
 */
class GameViewModel(application: Application) : AndroidViewModel(application) {

    // --- Dependencies and Presenter ---

    // Manually instantiated dependencies (ideally injected in a real app)
    private val settingsManager = SettingsManager(application.applicationContext)
    private val tokenManager = TokenManager(application.applicationContext)
    private val gson = Gson()
    private val repository = GameRepository(settingsManager, tokenManager)

    // The game logic controller
    private val presenter = GamePresenter(gson)

    // --- State Exposed to UI ---

    /**
     * Exposes the current, real-time game state to the UI.
     */
    val gameState: StateFlow<Game> = presenter.gameState

    /**
     * A flow indicating if a saved game exists and can be loaded.
     */
    val hasSavedGame: StateFlow<Boolean> = repository.getCurrentGameState()
        .map { it != null }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(), false)

    /**
     * Tracks the time elapsed since the game started.
     */
    private val _gameTime = MutableStateFlow(0L)
    val gameTime: StateFlow<Long> = _gameTime.asStateFlow()

    // --- Internal State ---

    // Job to manage the game timer coroutine.
    private var gameTimerJob: Job? = null
    private var isGameRunning = false

    // --- Initialization ---

    init {
        // Start collecting the current time from the game state whenever it changes
        viewModelScope.launch {
            gameState.collect { game ->
                // Ensure the ViewModel's timer starts from the correct saved value
                if (_gameTime.value != game.timeSeconds) {
                    _gameTime.value = game.timeSeconds
                }

                // If the game state reports a win, stop the timer and record stats
                if (game.isWon() && isGameRunning) {
                    stopGame()
                    recordGameWin(game.score)
                }
            }
        }
    }

    // --- Game Lifecycle Management ---

    /**
     * Starts a new game, optionally saving the current one if it exists.
     */
    fun startNewGame(saveCurrent: Boolean = true) {
        // Stop any running timers
        stopTimer()

        // If a game was running, save it before starting a new one
        if (saveCurrent && isGameRunning) {
            saveGame()
        }

        presenter.startNewGame()
        startGame()
    }

    /**
     * Attempts to load the last saved game state.
     */
    fun loadSavedGame(): Boolean {
        // Stop any running timers
        stopTimer()
        var loaded = false

        viewModelScope.launch {
            repository.getCurrentGameState()
                .firstOrNull() // Get the current value once
                ?.let { jsonString ->
                    loaded = presenter.loadGame(jsonString)
                    if (loaded) {
                        // Successfully loaded, start the game timer from the loaded time
                        startGame()
                        repository.clearSavedGame() // Clear saved state after loading
                    }
                }
        }
        return loaded
    }

    /**
     * Starts the game timer and marks the game as running.
     */
    private fun startGame() {
        isGameRunning = true
        startTimer()
    }

    /**
     * Stops the game (called when the game is won or the user exits/pauses).
     */
    fun stopGame() {
        stopTimer()
        isGameRunning = false
        // Save final state upon stopping (e.g., exiting the activity)
        saveGame()
    }

    // --- Timer Logic ---

    /**
     * Starts the coroutine for the game timer.
     */
    private fun startTimer() {
        // Cancel any existing job to prevent duplicates
        stopTimer()

        gameTimerJob = viewModelScope.launch {
            while (isActive) {
                delay(1000L) // Wait for 1 second
                _gameTime.update { it + 1 }
                // Update the time in the Game object itself for saving persistence
                presenter.currentGame.timeSeconds = _gameTime.value
            }
        }
    }

    /**
     * Stops the game timer coroutine.
     */
    private fun stopTimer() {
        gameTimerJob?.cancel()
        gameTimerJob = null
    }

    // --- Game Actions (Wrapper for Presenter) ---

    fun drawFromStock() {
        if (!isGameRunning) return
        presenter.drawFromStock()
        saveGame()
    }

    fun undoLastMove() {
        if (!isGameRunning) return
        presenter.undoLastMove()
        saveGame()
    }

    /**
     * Handles the complex move action from the UI.
     */
    fun handleCardMove(card: Card, sourceStack: CardStack, targetType: StackType, targetIndex: Int) {
        if (!isGameRunning) return

        val targetStack = presenter.getStack(targetType, targetIndex)
        val cardIndex = sourceStack.cards.indexOf(card)

        if (targetStack != null && cardIndex != -1) {
            presenter.moveCard(card, sourceStack, targetStack, cardIndex)
            saveGame() // Save state after every successful move
        }
    }

    // --- Persistence ---

    /**
     * Saves the current game state to the repository.
     */
    fun saveGame() {
        viewModelScope.launch {
            if (isGameRunning) {
                val json = presenter.serializeGame()
                repository.saveCurrentGameState(json)
            } else {
                repository.clearSavedGame()
            }
        }
    }

    // --- Statistics Recording ---

    private fun recordGameWin(finalScore: Int) {
        viewModelScope.launch {
            repository.recordGameWin(finalScore)
            repository.clearSavedGame() // Game is won, no need to save the state
            isGameRunning = false
        }
    }

    fun recordGameLoss() {
        viewModelScope.launch {
            repository.recordGameLoss()
            repository.clearSavedGame() // Game is lost/abandoned, no need to save the state
            isGameRunning = false
        }
    }

    // --- ViewModel Lifecycle ---

    override fun onCleared() {
        super.onCleared()
        // Ensure timer is stopped and game state is saved when ViewModel is destroyed (e.g., app closure)
        stopGame()
    }
}