package com.gpgamelab.justpatience

import android.content.Intent
import android.os.Bundle
import android.util.Log
import android.view.DragEvent
import android.view.MotionEvent
import android.view.View
import android.widget.Toast
import androidx.activity.viewModels
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import com.gpgamelab.justpatience.databinding.ActivityHomeBinding
import com.gpgamelab.justpatience.model.Card
import com.gpgamelab.justpatience.model.StackType
import com.gpgamelab.justpatience.viewmodel.GameViewModel
import com.gpgamelab.justpatience.ui.CardStackUIManager // Import the helper class
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import java.util.Locale

/**
 * The main activity for the Solitaire game.
 * Responsible for rendering the game state and handling user input events.
 */
class HomeActivity : AppCompatActivity() {

    private lateinit var binding: ActivityHomeBinding
    private val viewModel: GameViewModel by viewModels()

    // Manages the visual representation of all card stacks and handles drag-and-drop mechanics.
    private lateinit var cardStackUIManager: CardStackUIManager

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityHomeBinding.inflate(layoutInflater)
        setContentView(binding.root)

        setupToolbar()
        setupGameView()
        setupListeners()
        collectGameState()

        // Attempt to load a saved game on first launch
        if (savedInstanceState == null) {
            viewModel.loadSavedGame()
        }
    }

    // --- Lifecycle and Persistence ---

    override fun onPause() {
        super.onPause()
        viewModel.stopGame() // Stops the timer and saves the game state
    }

    override fun onResume() {
        super.onResume()
        // If the ViewModel has a running game, the timer will automatically restart on state collection
    }

    // --- Setup Methods ---

    private fun setupToolbar() {
        setSupportActionBar(binding.toolbar)
        supportActionBar?.title = getString(R.string.app_name)
    }

    private fun setupGameView() {
        // Initialize the UI manager with the main container and the necessary stacks
        cardStackUIManager = CardStackUIManager(this, binding.gameBoardContainer, viewModel)

        // The UIManager sets up the UI elements (card views) and attaches drag listeners.
        cardStackUIManager.initViews(
            stockId = R.id.stock_pile_container,
            wasteId = R.id.waste_pile_container,
            foundationIds = listOf(R.id.foundation_pile_0, R.id.foundation_pile_1, R.id.foundation_pile_2, R.id.foundation_pile_3),
            tableauIds = listOf(R.id.tableau_pile_0, R.id.tableau_pile_1, R.id.tableau_pile_2, R.id.tableau_pile_3, R.id.tableau_pile_4, R.id.tableau_pile_5, R.id.tableau_pile_6)
        )
    }

    private fun setupListeners() {
        binding.btnNewGame.setOnClickListener { showNewGameConfirmation() }
        binding.btnUndo.setOnClickListener { handleUndoClick() }
        binding.btnSettings.setOnClickListener { navigateToSettings() }
        binding.stockPileContainer.setOnClickListener { handleDrawStockClick() }

        // Observe the flow to enable/disable the 'Load Game' button
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.hasSavedGame.collectLatest { hasSavedGame ->
                    binding.btnLoadGame.isEnabled = hasSavedGame
                    // Show a toast or other visual cue if a saved game is available on launch
                    if (hasSavedGame) {
                        binding.btnLoadGame.setOnClickListener { showLoadGameDialog() }
                    } else {
                        binding.btnLoadGame.setOnClickListener(null)
                    }
                }
            }
        }
    }

    // --- State Collection and UI Update ---

    private fun collectGameState() {
        // Collect the game state (cards, score, move history)
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.gameState.collectLatest { game ->
                    // 1. Update general stats
                    binding.tvScore.text = getString(R.string.score_format, game.score)

                    // 2. Update card visuals
                    cardStackUIManager.render(game)

                    // 3. Check for win condition
                    if (game.isWon()) {
                        showWinDialog(game.score, game.timeSeconds)
                        viewModel.stopGame() // Ensure it saves and stops the timer
                    }
                }
            }
        }

        // Collect the game time separately for smooth timer update
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.gameTime.collectLatest { seconds ->
                    binding.tvTime.text = formatTime(seconds)
                }
            }
        }
    }

    // --- User Action Handlers ---

    private fun handleDrawStockClick() {
        viewModel.drawFromStock()
    }

    private fun handleUndoClick() {
        if (!viewModel.undoLastMove()) {
            Toast.makeText(this, R.string.no_moves_to_undo, Toast.LENGTH_SHORT).show()
        }
    }

    private fun navigateToSettings() {
        val intent = Intent(this, SettingsActivity::class.java)
        startActivity(intent)
    }

    // --- Dialogs and Confirmation ---

    private fun showNewGameConfirmation() {
        AlertDialog.Builder(this)
            .setTitle(R.string.new_game_title)
            .setMessage(R.string.new_game_message)
            .setPositiveButton(R.string.new_game_button_text) { _, _ ->
                viewModel.startNewGame(saveCurrent = true) // Save current game before starting new
                Toast.makeText(this, R.string.game_started, Toast.LENGTH_SHORT).show()
            }
            .setNegativeButton(R.string.cancel, null)
            .show()
    }

    private fun showLoadGameDialog() {
        AlertDialog.Builder(this)
            .setTitle(R.string.load_game_title)
            .setMessage(R.string.load_game_message)
            .setPositiveButton(R.string.load_game_button_text) { _, _ ->
                if (viewModel.loadSavedGame()) {
                    Toast.makeText(this, R.string.game_loaded, Toast.LENGTH_SHORT).show()
                } else {
                    Toast.makeText(this, R.string.load_error, Toast.LENGTH_SHORT).show()
                }
            }
            .setNegativeButton(R.string.cancel, null)
            .show()
    }

    private fun showWinDialog(score: Int, time: Long) {
        val timeFormatted = formatTime(time)
        AlertDialog.Builder(this)
            .setTitle(R.string.congratulations_title)
            .setMessage(getString(R.string.win_message, score, timeFormatted))
            .setPositiveButton(R.string.new_game_button_text) { _, _ ->
                viewModel.startNewGame(saveCurrent = false)
            }
            .setNegativeButton(R.string.continue_playing) { _, _ ->
                // User chose to continue, but the game is effectively won.
                // We'll just exit the dialog and let the user admire the board.
            }
            .setCancelable(false)
            .show()
    }

    // --- Utility ---

    /** Formats seconds into a MM:SS string. */
    private fun formatTime(totalSeconds: Long): String {
        val minutes = totalSeconds / 60
        val seconds = totalSeconds % 60
        return String.format(Locale.getDefault(), "%02d:%02d", minutes, seconds)
    }
}